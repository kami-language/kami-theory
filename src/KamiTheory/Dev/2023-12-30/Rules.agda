
{-# OPTIONS --allow-unsolved-metas --rewriting #-}

module KamiTheory.Dev.2023-12-30.Rules where

open import Agora.Conventions hiding (Œ£ ; Lift)
open import Agora.Data.Power.Definition
open import Data.Fin
open import Data.Nat hiding (_!)
open import Relation.Nullary.Decidable.Core

open import KamiTheory.Dev.2023-12-26.Core

{-# BUILTIN REWRITE _‚â°_ #-}

Name = ‚Ñï

module _ {A B : ùí∞ ùëñ} where
  transp-‚â° : (A ‚â° B) -> A -> B
  transp-‚â° refl-‚â° a = a

module _ {A : ùí∞ ùëñ} {B : ùí∞ ùëó} {C : ùí∞ ùëò} where
  cong‚ÇÇ-‚â° : (f : A -> B -> C) -> ‚àÄ{a‚ÇÄ a‚ÇÅ : A} -> ‚àÄ{b‚ÇÄ b‚ÇÅ : B} -> a‚ÇÄ ‚â° a‚ÇÅ -> b‚ÇÄ ‚â° b‚ÇÅ -> f a‚ÇÄ b‚ÇÄ ‚â° f a‚ÇÅ b‚ÇÅ
  cong‚ÇÇ-‚â° f refl-‚â° refl-‚â° = refl-‚â°

-- cong-‚â° : {A : ùí∞ ùëñ} {B : A -> ùí∞ ùëó} -> (f : (a : A) -> B a) -> {a b : A} -> (a ‚â° b) -> f a ‚â° f b
cong-‚â° : {A : ùí∞ ùëñ} {B : ùí∞ ùëó} -> (f : A -> B) -> {a b : A} -> (a ‚â° b) -> f a ‚â° f b
cong-‚â° f refl-‚â° = refl-‚â°

ap‚ÇÄ : ‚àÄ{A : ùí∞ ùëñ} {a b : A} -> a ‚â° b -> A
ap‚ÇÄ {a = a} _ = a

ap‚ÇÅ : ‚àÄ{A : ùí∞ ùëñ} {a b : A} -> a ‚â° b -> A
ap‚ÇÅ {b = b} _ = b

J1 : ‚àÄ{A : ùí∞ ùëñ} {B : ùí∞ ùëò} -> ‚àÄ{a b : A} -> (p : a ‚â° b) -> (F : A -> ùí∞ ùëó) -> (f : ‚àÄ a -> F a -> B) -> (x : F a) -> f b (transp-‚â° (cong-‚â° F p) x) ‚â° f a x
J1 refl-‚â° F f x = refl-‚â°



----------------------------------------------------------------
-- A new way forward:
--
-- We look at unifying the forall and existential quantification.
--
-- In the following sense:
--
--   When one has a sum ‚àë (a : A) (B a) then we don't add anything
--   to the context when showing b : B a, but we substitute the (a : A)
--   When one has a product ‚àè (a : A) (B a) then we don't have a value
--   for (a : A), but we add one into the context while checking B.
--   One could, instead, have a certain derivative (‚àÇ : Term -> Hom_Hole Œì Œì')
--   which describes how the negative parts of the context get modified
--   by the (a : A) term. If we write (hole ‚Ü¶ z) then with the `hole`
--   term we create a new hole, and as such, `(‚àÇ hole) Œì ‚â° (Œì , A)`
--   which means that (b : B a) gets a new A-variable. While if we don't
--   create a new hole, but merely project one from the context, then
--   this is also visible in the derivative: `(‚àÇ (var x)) (Œì , x , Œî) ‚â° (Œì , Œî , x)`.
--   But as one can see, no new variable is created.
--
--   We have a very strong _,_ operator: 
--   I can say:
--
--     hole a : ‚Ñï‚Åª
--
--     hole a , [ a + a ] : ‚àë (a : ‚Ñï‚Åª) (‚Ñï‚Å∫)
--
--     (hole a , [ a + a ]) , (a := 2) ‚áù [ 2 + 2]
--
--   This means:
--   f , (a := 2)  -- is valid "f 2"
--   f , (a + 2)   -- is also valid "Œª a ‚Ü¶ f a , a + 2"
--
--   We can write protocols as:
--   P ‚âî hole a , f a , hole b , g a b , hole c , hole d , x a c d
--   and we can apply them as:
--   P , (a := 2) ‚áù f 2 , hole b , g 2 b , hole c , hole d , x 2 c d
--   P , (a := 2) , (b := 3) ‚áù f 2 , g 2 b , hole c , hole d , x 2 c d
--
--   I can also transport holes from the context again into the term:
--   hole a , a + a , var a -- (but this makes the `a + a` term inaccessible?)
--
--   assume I have [f : -A ‚äó B , g : -B ‚äó C] in the context, then
--   ALL f , ALL g , (œÄ‚ÇÅ g := ALL(œÄ‚ÇÇ f)) : -A ‚äó C
--
--   Maps exist only in the non-charged flavor:
--    t : Œì ‚ä¢ [ -A ‚äó -A ] ‚áí [ -A ]
--    t = Œª (a0 , a1) ‚Ü¶ join a0 a1
--
--    s : Œì ‚ä¢ [ -A ‚äó B ] ‚äó [ -B ‚äó C ] ‚áí [ -A ‚äó C ]
--    s = Œª ((a , b0) , (b1 , c)) ‚Ü¶ (a , (b1 := b0) , c)
--
--    r : Œì ‚ä¢ (A ‚áí B) ‚áí [ -A ‚äó B ]
--    r = Œª f ‚Ü¶ hole a , f a
--
--    q : Œì ‚ä¢ [ -A ‚äó B ] ‚áí (A ‚áí B)
--    q = Œª (a0 , b) ‚Ü¶ Œª a ‚Ü¶ extract ((a0 := a) , b)
--
--    p : Œì ‚ä¢ (x : [ X ]) ‚áí ((a : ‚Üì x) ‚áí (‚Üë x a)) -- i.e., I can interpret a protocol x : X as a function from the inputs to the outputs
--
--
--   I might define _‚áí_ in terms of the _‚äó_ ?
--   Then I would say: A ‚áí B := [ -A ‚äó +B ]
--   Thus we would have:
--    t : Œì ‚ä¢ [ -[ -A ‚äó -A ] ‚äó +[ -A ]]
--    t = ?
--
--
--
--------------------------------------------------------
-- Choreographies
--
-- Our model is a topological space with space and time
-- arrow assignments.
--
-- We might *not* need a sophisticated time and space system,
-- though what do we need?
--
-- Next steps: Taking distributed algorithms and formulating
-- them with a dream syntax / typing.
--
--------------------------------------------------------
--
-- We have a new judgement type for communication types:
-- Example:
--  [ b ‚à∂ Bool Ôº† 0 ] ‚ä¢Comm [ Val b ](0 ‚Üí 1) ‚äó [ Val b ](1 ‚Üí 2)
--
-- In order to typecheck `Œì ‚ä¢[0 ‚Üí 1] (Val b)` we require that
-- we have `Œì ‚ä¢0 b`, that is, that the variable `b` is accessible
-- at location 0. Additionally, once we have [ Val b ](0 ‚Üí 1) in
-- the context, we get
--   `{ [ Val b ](0 ‚Üí 1) }‚ÜìÔº† 1`
--   ‚â° `{[ Val b ](0 ‚Üí 1) ‚ÜìÔº† 1 }`
--   ‚â° `{ Val b Ôº† 1 }`
--
-- It may be enough to only transmit variable values? It seems
-- simpler to do so, so let's do it.
--
-- Now how would we describe the transmission of a vector?
--
-- First, for a tuple:
--  { a : A Ôº† 0 , b : B Ôº† 0} ‚ä¢Comm [ A ](0 ‚Üí 1) ‚äó [ B ](0 ‚Üí 1)
--
-- For a vector we need a function:
--  T : {} ‚ä¢ ‚àÄ (n : ‚Ñï Ôº† {0 , 1}) -> (v : Vec A n Ôº† 0) -> CommType{0,1}
--  T zero [] = ùüô
--  T (suc n) (x ‚à∑ xs) = [ Val x ](0 ‚Üí 1) ‚äó T n xs
--
--
--  T : {} ‚ä¢ ‚àÄ (n : ‚Ñï Ôº† {0 , 1}) -> CommType{0,1}
--  T zero = ùüô
--  T (suc n) = [ A ](0 ‚Üí 1) ‚äó T n
--
-- NOTES:
--  The problematic part is letting "1" know which branch we take.
--  The rule is that if we pattern match on a value which is available
--  only at a certain number of locations, then only these locations should
--  observe differences in behaviour.
--  This means: assume (n : ‚Ñï Ôº† 0) is only available at "0". Then
--  the two branches of `T` should show unifiable behaviour at "1".
--  This can be achieved if we first send a Maybe value which says whether
--  we have an element or not.
--
--  T : {} ‚ä¢ ‚àÄ (n : ‚Ñï Ôº† 0) -> (v : Vec A n Ôº† 0) -> CommType{0,1}
--  T zero [] = [ Val nothing : Maybe A ](0 ‚Üí 1)
--  T (suc n) (x ‚à∑ xs) = [ Val (just x) : Maybe A ](0 ‚Üí 1) ‚äó T n xs
--
--  I can show observations:
--  O‚ÇÅ : ‚àÄ (n Ôº† 0) (v Ôº† 0) -> take0 (T n v ‚ÜìÔº† 1) ‚â° nothing -> n ‚â° 0
--                              ~~~~~~~~~~~~~~~~~~
--                                     ^ of type `Maybe A`
--
--                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~
--                                   ^ property Ôº† 1               ^ property Ôº† 0
--
-- NOTE: It looks like equality is special in the sense that we can have
-- an equality located at 1 which speaks about elements at 0.
--
-- This means that I can implement `T n v Ôº† 1` by doing the following:
--
-- t‚ÇÅ : ‚àÄ (n Ôº† 0) (v Ôº† 0) -> T n v ‚ÜìÔº† 1
-- t‚ÇÅ n v = hole (x : Maybe A) , case x of (nothing ‚Ü¶ ... using O‚ÇÅ ... need: nothing, done)
--                                         (just x ‚Ü¶ )
--
-- Let's take fancy holes, maybe that works:
--
--  T : {} ‚ä¢ ‚àÄ (n : ‚Ñï Ôº† 0) -> (v : Vec A n Ôº† 0) -> CommType{0,1}
--  T zero [] = [ Val nothing : Maybe A ](0 ‚Üí 1)
--  T (suc n) (x ‚à∑ xs) = [ Val (just x) : Maybe A ](0 ‚Üí 1) ‚äó T n xs
--
-- We have `‚à• T n v ‚à• ‚â° [ Maybe A ](0 ‚Üí 1) ‚äó {(zero‚Åª¬π n) ‚à£ T (suc‚Åª¬π n) (cons‚Åª¬π xs)}`
--
-- I can show: for (x : T n v Ôº† 1) -> Take0 x ‚â° nothing -> (n ‚â° 0)
--             for (x : T n v Ôº† 1) -> Take0 x ‚â° just val ->  ‚àÉ (n' Ôº† 0). (n ‚â° suc n') -> Take1 x
--
-- Another approach:
--
-- If : Bool -> ùí∞ -> ùí∞
-- If true A = A
-- If false A = ùüô
--
-- SendOne : (b : Bool Ôº† 0) -> (If b A Ôº† 0) -> CommType{0,1}
-- SendOne b x = [ Val b ] ‚äó 
--
-- splitList : List A -> (b : Bool) ‚äó If b (A ‚äó List A)
-- splitList [] = false , tt
-- splitList (x ‚à∑ xs) = true , (x , xs)
--
-- SendList : (xs : List A Ôº† 0) -> CommType{0,1}
-- SendList xs = let (b , head&tail) = splitList xs
--               in [ Val b ](0 ‚Üí 1) ‚äó case b of
--                                       false -> ùüô
--                                       true -> let (head , tail) = head&tail
--                                               in [ Val head ](0 ‚Üí 1) ‚äó SendList tail
--
-- Let's say we have "Tag"-types for sum types. Then we can only pattern match in
-- a {0,1} context on a sum type if the tag is available at all locations without
-- necessarily the data itself.
--
-- SendList : (xs : List A Ôº† 0) -> CommType{0,1}
-- SendList xs = [ Val (tag xs) ](0 ‚Üí 1) ‚äó case xs { [] ‚Ü¶ ùüô | (x ‚à∑ xs) ‚Ü¶ [ Val x ](0 ‚Üí 1) ‚äó SendList xs }
--
-- I want to show:
-- sendList : (xs : List A Ôº† 0) -[ SendList xs ]-> (Val xs {T = List A} Ôº† 1)
--
-- Note: the function not only sends a list, but the typesystem knows that it
-- is the same list now at 1.
--
-- sendListÔº†0 xs =
--   tag xs ,
--   case xs
--     { []       ‚Ü¶ tt
--     , (x ‚à∑ xs) ‚Ü¶ x , sendListÔº†0 xs
--     }
--
-- sendListÔº†1 = hole xs , case xs { [] ‚Ü¶ tt , [] | (_ ‚à∑ _) ‚Ü¶ hole x , xs = sendListÔº†1 , (x ‚à∑ xs) }
--
-- I also can implement them at once:
--
-- sendList xs =
--   send(0 ‚Üí 1) (tag xs) ,
--   case xs
--     { []       ‚Ü¶ (ttÔº†0 , []Ôº†1)
--     | (x ‚à∑ xs) ‚Ü¶ (x' = send(0 ‚Üí 1) x) , (xs' = sendList xs) , (ttÔº†0 , (x' ‚à∑ xs')Ôº†1)
--     }
--
--------------------------------------------------------
-- Example: summing n numbers: https://arxiv.org/pdf/1911.00705.pdf (page 16)
--
-- Idea: client sends `n` and then n numbers, the server sums them all up, and
-- returns the result.
--
-- Ex‚Çä : (n : ‚ÑïÔº†0,1) -> CommType{0,1}
-- Ex‚Çä zero = [ ‚Ñï ](1 ‚Üí 0)
-- Ex‚Çä (suc n) = [ ‚Ñï ](0 ‚Üí 1) ‚äó Ex‚Çä n
--
-- Ex : (n : ‚ÑïÔº†0) -> CommType{0,1}
-- Ex n = [ Val n ](0 ‚Üí 1) ‚äó Ex‚Çä n
--
-- ex‚Çä : ‚àÄ(n Ôº† 0,1) -> ‚àÄ(v : Vec ‚Ñï n Ôº† 0) -> (acc : ‚Ñï Ôº† 1) -[ Ex‚Çä n ]-> ‚Ñï Ôº† 0
--
-- ex‚ÇäÔº†0 zero _ = hole res &‚Üë res
-- ex‚ÇäÔº†0 (suc n) (x ‚à∑ xs) = x , exÔº†0 n x
--
-- ex‚ÇäÔº†1 zero acc = acc
-- ex‚ÇäÔº†1 (suc n) acc = hole x , ex‚ÇäÔº†1 n (x + acc)
--
-- Now implemented choreographically:
-- ex‚Çä zero [] acc = (resÔº†0 ‚áú accÔº†1) , &‚Üë res
-- ex‚Çä (suc n) (x ‚à∑ xs) acc = (xÔº†1 ‚áú xÔº†0) , ex‚Çä n xs (acc + x)
--
-- ex : ‚àÄ(n Ôº† 0) -> ‚àÄ(v : Vec ‚Ñï n Ôº† 0) -[ Ex n ]-> ‚Ñï Ôº† 0
-- ex n v = (nÔº†1 ‚áú nÔº†0) , ex‚Çä n v 0
--
----------------------------------------------------------------
-- Example: indirect information: https://link.springer.com/article/10.1007/s10270-022-01040-x (example 3.1, page 4)
--
-- Idea: (quote)
-- ```
--    As a running example, let us consider three par-
--    ticipants p, q, r. p chooses whether to send a message to r or
--    not; this choice is communicated to r through an intermediate
--    participant q.
-- ```
--
-- Note: renaming processes [p,q,r] ‚Ü¶ [0,1,2]
--
-- Ex : (b : Bool Ôº† 0) -> CommType{0,1,2}
-- Ex b = [ Val b ](0 ‚Üí 1) ‚äó [ Val b ](1 ‚Üí 2) ‚äó If b ([ A ](0 ‚Üí 2))
--
-- ex : (b Ôº† 0) -> (a : A Ôº† 0) -> If b A Ôº† 2
-- ex b a = (bÔº†2 ‚áú bÔº†1 ‚áú bÔº†0) , case b { true ‚Ü¶ (aÔº†2 ‚áú aÔº†0) &‚Üë a | false ‚Ü¶ tt}
--
----------------------------------------------------------------
-- Example: two-buyers problem: https://link.springer.com/article/10.1007/s10270-022-01040-x (example 3.2, page 5)
--
-- Idea: (quote)
-- ```
--    A second running example is the well-known
--    two-buyers problem, as in [17]. First Buyer 1 sends a book
--    title to Seller, then Seller sends back a quote to both Buyer 1
--    and Buyer 2, then Buyer 1 tells Buyer 2 how much she wants
--    to contribute, and Buyer 2 tells Seller if she accepts the quote
--    or not. If the deal is drawn, Seller tells Buyer 2 the expected
--    delivery date at her address.
-- ```
--
-- ...
--
----------------------------------------------------------------
-- Example: dining philosophers
--
-- We have three processes which are locally correct, but where
-- combining all of them produces a deadlock.
--
-- The local types look like this:
--
-- P0 : CommType{0,1,2}
-- P0 = [ ‚Ñï ](2 ‚Üí 0) ‚äó [ ‚Ñï ](0 ‚Üí 1)
--
-- P1 : CommType{0,1,2}
-- P1 = [ ‚Ñï ](0 ‚Üí 1) ‚äó [ ‚Ñï ](1 ‚Üí 2)
--
-- Interestingly enough, we currently have no way to specify
-- invalid (deadlocking) "local" types. If we want to implement
-- three processes, we have to give a global type for them.
-- There is no way to "merge" three "partial" types to get a
-- possibly invalid global type.
--
----------------------------------------------------------------
-- Development/Thinking. Topic: Remote resources, channels
--
-- We have seen that it is nice in some sense that we don't have
-- "local session types". But we still want to extract channels
-- in the sense that we can have a server whose implementation
-- we don't have access to, but who we can still talk to.
--
-- Let us try to use our global types + hyper-local types for that.
--
-- We have a situation where a server can be accessed by various
-- clients... Because assuming we have fixed roles, implementing
-- for only some of the roles is already possible in our theory.
--
-- Idea: we have a "global name service" which can connect us to
-- a server we want to talk with.
--
-- We say that we want to speak with "test.determi.io", and we
-- get a partially implemented term with the type of this program.
-- This means that we need to at least be able to compare types
-- to make sure that our partner behaves as we expect.
--
-- getRandom : ‚Ñï Ôº† 0
-- getRandom =
--   (T : CommType{0,Server}, t : T‚ÜìServer) <- getChannel "test.determi.io"
--   assert T ‚â° [ n : ‚Ñï ](0 ‚Üí Server) ‚äó [ Fin n ](Server ‚Üí 0)
--   let t‚ÇÄ : (ùüô -[ T ]-> ‚Ñï Ôº† 0)  ‚Üì 0
--          = (n : ‚Ñï) ‚äó (- Fin n) ‚äó ‚Ñï
--       t‚ÇÄ = 100 , hole i , cast i
--   in (pair t t0) tt : ‚Ñï Ôº† 0
--
-- Here we get `t`, a partial implementation of the `T` protocol.
-- If we have a partial implementation in scope, we are obliged to
-- discharge such an assumption. We do this by providing the rest
-- of the implementation with `t‚ÇÄ`, and then we discharge by combining
-- them with `pair`.
--
-- This suggests that there is some kind of scheduling operation
-- which takes a partial implementation and runs it, but passes
-- the "channel" (without I/O-state) somewhere else, such that
-- another process can connect to this server.
--
-- t‚ÇÅ :{1} ‚ÑïÔº†1 -[ T ]-> ‚ÑïÔº†1
-- t‚ÇÅ = ?
--
-- t : (‚àÄ Œ±. Channel T (0,Œ±) {0}) -> ‚ÑïÔº†1 -[ T ]-> ‚ÑïÔº†1
-- t c n = pair (c 1) t‚ÇÅ
--
-- Where `(‚àÄ Œ±. Channel T (0,Œ±) {0})` means that this is a channel
-- to an implementation of `T` where the type T is located at 0 and Œ±,
-- it is implemented only for 0, and we can choose ourselves what Œ±
-- should be.
--
----------------------------------------------------------------
-- Remote resources & location ownership
--
-- Let us assume that we want proper channels. Then we have multiple
-- concepts:
--  1. The location (server) where the code is executed.
--  2. The location (scheduler) which knows about the server and can
--     provide us with a channel to it.
--  3. The location (client) which accesses the server.
--
-- Communication types (channels) are implemented incrementally.
-- Each location can schedule part of a communication, and gets
-- an according channel as proof of scheduling. Channels with matching
-- role implementations can be joined. A fully implemented channel can
-- be consumed by whichever location. This location is playing the role
-- of the connector, i.e., telling the individual participants their
-- partners, and thus establishing the connection/protocol.
--
-- Assume I have `T : CommType{Œ±,Œ≤}`.
--
-- T : CommType{Œ±,Œ≤}
-- T = [ ‚Ñï ](Œ± ‚Üí Œ≤) ‚äó [ ‚Ñï ](Œ≤ ‚Üí Œ±)
--
-- t‚ÇÄ : {0,(Œ±)} -> ‚ÑïÔº†0 -[ T ]-> ‚ÑïÔº†0
-- t‚ÇÄ = ?
--
-- step : {S,0} -> ‚ÑïÔº†0 -> (‚ÑïÔº†0 √ó Chan T {0,(Œ±)} Ôº†S)
-- step n = schedule t‚ÇÄ n (0 under S)
--
-- scheduler :{S} -> ‚ÑïÔº†S -> !(Chan T {0,(Œ±)})
-- scheduler = ?
--
-- Now assume I have two processes talking with the scheduler.
--
-- U : CommType{S,a,b}
-- U = [Chan T {0,(Œ±)}](S ‚Üí a) ‚äó [Chan T {0,(Œ≤)}](S ‚Üí b)
--
--
-- u‚ÇÅ :{(0),1} -[ T ]-> ùüô
-- u‚ÇÅ = hole n , n + 1
--
-- u :{S,1,2} -> ‚ÑïÔº†S -[ U ]-> ùüô
-- uÔº†0 = hole c‚ÇÄ , connectÔº†1 {c‚ÇÄ , schedule u‚ÇÅ}
--             ~~                    ~~~~~~~~~~~
--             ^                     ^ Chan T {(0), 1}
--             | Chan T {0,(Œ±)}
--
--                             ~~~~~~~~~~~~~~~~~
--                             ^ Chan T {(0),(1)}
--
-- We see that if we have `f : {0,1} -> A -[ U ]-> B`, we can
-- do `f‚Üì0 : {0,(1)} -> A‚Üì0 -[ U ]-> B‚Üì0`.
-- And we have:
-- f ‚â° Œª a ‚Ü¶ connect {schedule (f‚Üì0 a‚Üì0) , schedule (f‚Üì1 a‚Üì1)}
--
-- The idea is as follows:
--  - partial implementations are copyable, but not proper terms,
--    in that they cannot be executed stand-alone.
--  - partial implementations can be scheduled, which creates a
--    channel signifying the "implemented vs missing" information.
--    This channel is not copyable.
--  - Channels can be merged if they implement the different aspects
--    of the same communication type
--  - Once a channel is fully implemented, it can be discarded with `connect`.
--
-- Again:
-- We see that if we have `f : {0,1} -[ U ]-> B`, we can
-- do `f‚Üì0 : {0,(1)} -[ U ]-> B‚Üì0`.
-- And we have:
-- f ‚â° (let (ca , va) = schedule (f‚Üì0)
--           (cb , vb) = schedule (f‚Üì1)
--      in connect {ca , cb} , (va , vb)
--      )
--
----------------------------------------------------------------
-- Schedule and related things
--
-- The current problem is that schedule acts on two locations.
-- There is the hosts' location and the clients'. The question is,
-- is this really required, or just accidental?
-- What schedule has to do, is:
--  - take a partial implementation of a Comm-Type and instantiate
--    it once, providing us with the return type, and with the
--    Channel for communicating with this instance.
-- It seems like this behaviour does not require multiple locations.
--
-- On the other hand, such a scheduled computation has to run on
-- a different thread than the scheduler because while the scheduler
-- is free to act and send the channel, the scheduled task has to
-- wait until it is connected...
--
-- This means that a choreography `f : {0,1} -[ T ]-> B` is itself
-- not yet scheduled? We can schedule it, and what we get, is a scheduling
-- of the parts on the locations `0` and `1`. But this means that
-- there is also the (full) channel on the supervisor location which
-- is dropped.
--
-- so we have to say:
--
-- t : {S,0,1} -> BÔº†{0,1}
-- t = let (c , v) = schedule f in connect c , v
--          ~   ~
--          ^   ^ v : B Ôº†{0,1}
--          | c : Chan T {(0),(1)} Ôº†S
--
-- Is a supervisor divisible from a scheduled process? That is,
-- is there a term which describes "scheduling" individually for
-- S and 0? Can I project to only S or only 0?
--
-- Apriori it seems like communication between supervisor and
-- process is different than between various processes. This means
-- that I cannot project onto every location.
--
--
-- Locally, a choreography begins with:
--  - Knowing my own code
--  - Knowing the identity of my communication partners
--
-- This means: If I know the identity, I don't need any communications
-- to start... Well not exactly. I still need to know that my partners
-- are actually also doing the appropriate thing. This (virtual) information
-- has to be delivered to me from my supervisor. Which again is only possible
-- if my supervisor is behaving correctly and going to give me that information.
-- Thus matching choreographies are not solvable from an "information"
-- point of view.
--
-- Now assume that the type system can guarantee me that, if I know my partners,
-- that they are doing the correct thing.
--
-- For that, we take choreographies as basis. Partial implementations are especially
-- marked. The program is only well-written if it is a combined term (defined for
-- all participants).
--
----------------------------------------------------------------
-- About external participants
--
-- What we want to allow is: Defining a server which accepts connections
-- from various clients and executes choreographies with them.
--
-- This is an asymetric situation: The choreographies themselves are
-- for two participants, but the overall architecture is one where
-- the server does not know the names and locations of its clients before-
-- hand. This means that we are required to encode this somehow.
--
-- This means, we have a two-loc choreography T.
--
-- T : CommType{0,Œ±}
-- T = ?
--
-- Now we want to create a server which does not know its clients.
--
-- Server : {0} -[ ŒΩ Œ±. T{0,(Œ±)} ]-> ùüôÔº†0
--
-- The interesting thing is that `ŒΩ Œ±` is part of the CommType.
-- Which makes sense since there has to happen a communication
-- to connect a client with the server.
--
----------------------------------------------------------------
-- Indeterminacy
--
-- Assume I have three locations {0,1,2}. Now we want to write a
-- CommType{0,1,2} which expresses the fact that 2 will receive a
-- message from either 0 or 1, without knowing from whom - until
-- it gets the message.
--
-- This means we have something like:
--
-- S : CommType{0,1,2}
-- S = ŒºÔº†0 ‚àà {1,2}. [ A ](Œº ‚Üí 0)
--
-- Now:
-- s‚ÇÅ : {(0),1,(2)} -> AÔº†1 -[ S ]-> ùüôÔº†1
-- s‚ÇÅ a = (Œº = 1) , a
--
-- s‚ÇÇ : {(0),(1),2} -[ S ]-> ùüôÔº†2
-- s‚ÇÇ = (Œº = 1) , tt
--
-- s‚ÇÄ : {0,(1),(2)} -[ S ]-> AÔº†0
-- s‚ÇÄ = (select-hole Œº) , hole a , a
--
-- We need that both s‚ÇÅ and s‚ÇÇ decide on the same role to send,
-- s‚ÇÄ does not need to participate in the decision, only has to
-- receive the outcome.
--
-- But this is like this because Œº is in a contravariant position.
-- If we had `Œº‚àà{1,2}. [ A ](0 ‚Üí Œº)`, then we would send a message
-- to either of {1,2} - but these processes don't know who is going
-- to be the target. We might say that there has to be some `ŒºÔº†{0,1,2}`,
-- though we don't care how it is decided. So we might say:
--
-- S : ŒºÔº†{0,1,2} ‚àà {1,2} -> CommType{0,1,2}
-- S Œº = [ A ](Œº ‚Üí 0)
--
-- s‚ÇÅ : (Œº : {1,2} Ôº†{0,1,2}) -> AÔº†Œº -[ S Œº ]-> AÔº†0
--
-- So what we need is some communication which can create
--
-- f : {0,1,2} -> X -> {1,2}Ôº†{0,1,2}
-- f = ?
--
-- Then we can do
-- g : {0,1,2} -> (x : X) -> AÔº†(f x) -[ S (f x) ]-> AÔº†0
--
-- The thing is that in this case, the participants are already clear.
-- When we have a server and a random client though, the participants
-- are potentially everyone on the internet.
--
-- This means that the procedure to choose who is going to connect to
-- the server involves an arbiter. But that does not solve the underlying
-- problem. Since there still needs to be some connection event where one
-- client connects to the arbiter, who doesn't know where the connection
-- might come from.
--
-- The solution that first, there has to be a communication which decides
-- the source-role is not applicable since this would be a communication
-- between all devices on the net.
--
-- This means that there is a CommType as follows:
--
-- T : CommType{0,1,2}
-- T = (Open Œº‚àà{1,2} ‚Üí 0) ‚äó [ A ](Œº ‚Üí 0)
--
-- s‚ÇÅ : {(0),1,(2)} -[ T ]-> ùüô
-- s‚ÇÅ = open 0 , a‚ÇÅ | tt
--
-- s‚ÇÇ : {(0),1,(2)} -[ T ]-> ùüô
-- s‚ÇÇ = open 0 , a‚ÇÇ | tt
--
-- The interesting thing is that we don't know whether the connection
-- will be successful. 
--
-- Also, this makes the 1 and 2 participants of T more optional.
-- We don't know whether they will participate...
--
-- T : CommType{0,{1,2}}
-- T = (Open Œº‚àà{1,2} ‚Üí 0) ‚äó [ A ](Œº ‚Üí 0)
--                            ~~~~~~~~~~~~
--                            ^ : CommType{0,Œº} <- here Œº is no longer optional,
--                                                 because a decision has been made.
--
-- This means that T does not have to be implemented for the optional roles...
-- But we need a "global name" for other processes to participate?
-- Or we say that `Port 5000 : RoleSet`, and:
--
-- T : (R : Roleset) -> CommType{0,{R}}
-- T = (Open Œº‚ààR ‚Üí 0) ‚äó [ A ](Œº ‚Üí 0)
--
-- Then we can:
-- main =
--   let R : Roleset
--       R = newroleset
--
--       t : {0} -[ T R {0} ]-> ùüô
--       t = ?
--
--       s : {1 ‚àà R} -[ T (1‚ààR) {1} ]-> ùüô
--       s = ?
--
-- Let's reiterate:
-- T : (R : RoleSet) -> CommType{0,Œº‚ààR,ŒΩ‚ààR}
-- T R = Accept Œº. [ A ](Œº ‚Üí 0) ‚äó Accept ŒΩ. [ A ](0 ‚Üí ŒΩ)
--
-- t‚ÇÄ : (R : RoleSet) -[ T R Ôº† 0 ]-> ùüô
-- t‚ÇÄ R = accept Œº , hole a , accept ŒΩ , a
--
-- R : RoleSet
-- R = Global
--
-- t‚ÇÅ : {1} -> AÔº†1 -[ T R Ôº† 1 ]-> AÔº†1
-- t‚ÇÅ a = connect Œº { Œº = 1 ‚Ü¶ a , a                                               : T R Ôº† 1 (Œº ‚âî 1)
--                  | Œº ‚â† 1 ‚Ü¶ connect ŒΩ { ŒΩ = 1 ‚Ü¶ hole b , b | ŒΩ ‚â† 1 ‚Ü¶ a }     : T R Ôº† 1 (Œº ‚â† 1)
--                  }                      ~~~~~~~~~~~~~~~~~~~
--                                         ^ : T R Ôº† 1 (Œº ‚â† 1)(ŒΩ = 1)
--
-- Now to reduce these terms, we need to know the exact R, and we need to
-- consider all possibilities for (Œº ‚àà R , ŒΩ ‚àà R).
--
-- Can we extract the indeterministic source or do we have to apply it step-by-step?
-- If things get dependently typed, step-by-step is the only way.
--
-- Given a T : CommType{...}, we get Trace T : TraceType{...}, the tracetype
-- tells us which choices appear during execution.
--
-- If we have a term `t : {...} -[ T ]-> X`, then we can compute
-- `t ‚áù[ c ] : X` if we have `c : Trace T`. For choreographies
-- this `Trace T` is a singleton type because the communication
-- happens deterministically, once one knows all input data. For
-- more advanced communication patterns this is not so. Thus, we can
-- forget the -[ T ]-> annotation only if `Trace T` is trivial.
--
-- Adding open connections with `Accept Œº. t` terms, the trace type
-- is no longer deterministic (contractible). This means that the
-- execution of such a term might (!) be nondeterministic, and can
-- be only predicted if we know all choices beforehand (c : Trace T).
--
--
----------------------------------------------------------------
-- Variable forwarding
--
-- For channel types to be dependent, we need to have knowledge over a common
-- Œì{0,1} context. Now assume I have [ a : AÔº†0 ], how do I get the knowledge
-- accross to 1? 
--
-- If I have:
--
-- T : CommType{0,1}
-- T = ‚üÆ0 ‚Üí 1‚üØ[ A ] ‚äó ‚üÆ1 ‚Üí 0‚üØ[ B ]
--
-- t‚ÇÅ : (-A ‚äó +B) -> T‚Üì1
-- t‚ÇÅ (a , b) = hole x , (a := x) b
--
-- or
--
-- t‚ÇÅ (a , b) = a , b
--
--
----------------------------------------------------------------
-- Examples for Olivia
--
-- T : CommType{0,1}
-- T = (a : ‚üÆ0 ‚Üí 1‚üØ[ A ]) ‚äó ‚üÆ1 ‚Üí 0‚üØ[ B a ]
--
-- t‚ÇÄ : (f : (A -> B)Ôº†1) -[ T Ôº† 1 ]-> ùüô
--
-- t‚ÇÅ : (a : AÔº†0) -[ T Ôº† 0 ]-> BÔº†0
--
--
--
-- Also eine Frage an dich, angenommen wir haben
--
-- T : CommType{0,1}
-- T = ‚üÆ0 ‚Üí 1‚üØ[ A ] ‚äó ‚üÆ1 ‚Üí 0‚üØ[ B ]
--
-- und dann wollen wir T fuer beide rollen einzeln implementieren. Die Idee ist, dass fuer die implementation *nur* die lokalen typen relevant sind und es ueberhaupt keine rollenannotationen gibt. Ich hab jetzt davor bei unseren Beispielen aber trotzdem immer so globale types (also mit @0 und @1 annotationen) fuer die lokalen implementationen t0 und t1 geschrieben... Wie wuerdest du die echten lokalen types fuer die beiden folgenden zueinander passenden implementationen von T aufschreiben? Ich hab die mal wieder mit so "fake local types" aufgeschrieben:
--
-- t‚ÇÄ : (f : (A -> B)Ôº†1) -[ T Ôº† 1 ]-> ùüô
--
-- t‚ÇÅ : (a : AÔº†0) -[ T Ôº† 0 ]-> BÔº†0
--
--
----------------------------------------------------------------
-- Without negative types
--
-- T : CommType{0,1}
-- T = [ A ](0 ‚Üí 1)
--
-- t‚ÇÄ : A -> ‚àë A -> ùüô
-- t‚ÇÄ a = a , tt
--
-- t‚ÇÅ : ‚àè A -> A
-- t‚ÇÅ = Œª a ‚Ü¶ a
--
-- t : (a : A Ôº† 0) -[ T ]-> AÔº†1
-- t a = (bÔº†1 ‚áú aÔº†0) ‚ñ∂ b
--
-- _‚áú_‚ñ∂_
--
----------------------------------------------------------------
--
-- T : CommType{0,1,2}
-- T = ‚üÆ0 ‚Üí 1‚üØ[ A ] ‚äó ‚üÆ1 ‚Üí 2‚üØ[ B ] ‚äó ‚üÆ2 ‚Üí 0‚üØ[ B ]
--
-- TÔº†0 = ‚àë 
--
-- h : (a : AÔº†0) -> (t : T) -> C a ?
-- Œì ‚ä¢ T CommType      Œì , ‚Üì T ‚ä¢ C Type
-- ------------------------------------
--         Œì ‚ä¢ -[ T ]-> C Type
--
----------------------------------------------------------------
-- Variable forwarding, part 2
--
-- We are, in fact, forwarding arbitrary values. Mostly because
-- variables are not stable under substitution. Now assume that
-- we have `a : A Ôº† 0`. We can form the type `Val{0} a Ôº† 1`
-- which says that we know the value of `a` at location 1.
-- If we have `t : A Ôº† i` and `s : Val{i} t Ôº† j` we can build
-- {t,s} : A Ôº†{i;j}




----------------------------------------------------------------
-- Current questions:
--  - How do we represent "no communication"? Is it enough if we say that
--    the type ùüô does not require any communication? Do we need sth more
--    formal?
--  - Currently, the local implementations to do not retain the information
--    with whom they communicate. This is not future-proof, in the sense
--    that during compilation we are definitely going to need this information.
--    Usually such information is kept in "local session types" which we currently
--    do not represent. This has the effect that the dining philosopher deadlock
--    cannot even be stated.
--  - What is the relationship between partial implementations and channels?
--    partial implementations have input and output types, and have to be "scheduled"
--    in order to get a channel which can be communicated to other processes...
--    In some sense, the scheduler owns the processes which it has scheduled...
--    We might have a difference between "internal" and "external" locations:
--    The scheduler in "Topic: Remote resources, channels" owns the location `0`,
--    while the term `t` does not. It can still instantiate the protocol T to {0,1},
--    but it cannot schedule anything to location 0.
