
{-# OPTIONS --allow-unsolved-metas --rewriting #-}

module KamiTheory.Main.Generic.ModeSystem.2Graph.Example where

open import Agora.Conventions
open import Agora.Order.Preorder
open import KamiTheory.Basics

open import KamiTheory.Main.Generic.ModeSystem.2Graph.Definition


module SendReceiveNarrow-2Graph (P : Preorder 𝑖) {{_ : hasDecidableEquality ⟨ P ⟩}} {{_ : ∀{a b : ⟨ P ⟩} -> isProp (a ≤ b)}} where

  private variable
    U V : ⟨ P ⟩

  ---------------------------------------------
  -- modes

  -- modes are "copies" of MLTT inside our type theory
  data Mode-SRN : Set where
    ▲ : Mode-SRN -- the local mode
    ◯ : Mode-SRN -- the global mode

  ---------------------------------------------
  -- mode homomorphisms (modalities)

  -- modalities are morphisms between modes,
  -- they are generated by the following two
  -- base mode homs.
  data BaseModeHom-SRN : (m n : Mode-SRN) -> 𝒰 (𝑖 ⌄ 0) where
    `＠` : ∀(U : ⟨ P ⟩) -> BaseModeHom-SRN ▲ ◯
    `[]` : BaseModeHom-SRN ◯ ▲

  ---------------------------------------------
  -- mode transformations

  data BaseModeTrans-SRN : Visibility -> {m n : Mode-SRN} (μs ηs : Path BaseModeHom-SRN m n) -> 𝒰 𝑖 where
    send : ∀ U -> BaseModeTrans-SRN vis id (`＠` U ⨾ `[]` ⨾ id)
    recv : ∀ U -> BaseModeTrans-SRN vis (`[]` ⨾ `＠` U ⨾ id) id
    narrow : U ≤ V -> BaseModeTrans-SRN invis (`＠` U ⨾ id) (`＠` V ⨾ id)


  ------------------------------------------------------------------------
  -- Decidability

  decide-≡-Mode-SRN : (x y : Mode-SRN) → isDecidable (x ≡ y)
  decide-≡-Mode-SRN ▲ ▲ = yes refl-≡
  decide-≡-Mode-SRN ▲ ◯ = no (λ ())
  decide-≡-Mode-SRN ◯ ▲ = no (λ ())
  decide-≡-Mode-SRN ◯ ◯ = yes refl-≡

  instance
    hasDecidableEquality:Mode-SRN : hasDecidableEquality Mode-SRN
    hasDecidableEquality:Mode-SRN = record { _≟_ = decide-≡-Mode-SRN }

  decide-≡-BaseModeHom-SRN : ∀{a b} -> (x y : BaseModeHom-SRN a b) → isDecidable (x ≡ y)
  decide-≡-BaseModeHom-SRN (`＠` U) (`＠` V) with U ≟ V
  ... | no p = no λ {refl -> p refl}
  ... | yes refl = yes refl
  decide-≡-BaseModeHom-SRN `[]` `[]` = yes refl

  instance
    hasDecidableEquality:BaseModeHom-SRN : ∀{a b} -> hasDecidableEquality (BaseModeHom-SRN a b)
    hasDecidableEquality:BaseModeHom-SRN = record { _≟_ = decide-≡-BaseModeHom-SRN }

  decide-≡-BaseModeTrans-SRN : ∀{v a b} -> {μ η : Path BaseModeHom-SRN a b} -> (x y : BaseModeTrans-SRN v μ η) → isDecidable (x ≡ y)
  decide-≡-BaseModeTrans-SRN (send U) (send .U) = yes refl
  decide-≡-BaseModeTrans-SRN (recv U) (recv .U) = yes refl
  decide-≡-BaseModeTrans-SRN (narrow ϕ) (narrow ψ) with force-≡ ϕ ψ
  ... | refl = yes refl

  instance
    hasDecidableEquality:BaseModeTrans-SRN : ∀{v a b} -> {μ η : Path BaseModeHom-SRN a b} -> hasDecidableEquality (BaseModeTrans-SRN v μ η)
    hasDecidableEquality:BaseModeTrans-SRN = record { _≟_ = decide-≡-BaseModeTrans-SRN }


  SRN : 2Graph _
  SRN = record
    { Point = Mode-SRN
    ; Edge = BaseModeHom-SRN
    ; Face = BaseModeTrans-SRN
    }



