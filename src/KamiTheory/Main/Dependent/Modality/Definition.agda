
{-# OPTIONS --allow-unsolved-metas #-}

module KamiTheory.Main.Dependent.Modality.Definition where

open import Agora.Conventions


------------------------------------------------------------------------
-- The new modality system

---------------------------------------------
-- modes

-- modes are "copies" of MLTT inside our type theory
data Mode : Set where
  â–² : Mode -- the local mode
  â—¯ : Mode -- the global mode


---------------------------------------------
-- modalities

-- modalities are morphisms between modes,
-- they are generated by the following two
-- base mode homs.
data BaseModeHom P : (m n : Mode) -> Set where
  `ï¼ ` : âˆ€(U : P) -> BaseModeHom P â–² â—¯
  `[]` : BaseModeHom P â—¯ â–²

-- in general, modalities are concatenations
-- of base modalities
data ModeHom P : (m n : Mode) -> Set where
  id : âˆ€{m} -> ModeHom P m m
  _â¨¾_ : âˆ€{m n o} -> BaseModeHom P m n  -> ModeHom P n o -> ModeHom P m o

infixr 80 _â¨¾_

record Modality P : Set where
  constructor _â†_âˆ‹_
  field dom : Mode
  field cod : Mode
  field hom : ModeHom P dom cod

infixl 40 _â†_âˆ‹_

open Modality public

_â—†_ : âˆ€{P m n k} -> ModeHom P m n -> ModeHom P n k -> ModeHom P m k
id â—† q = q
(x â¨¾ p) â—† q = x â¨¾ (p â—† q)


---------------------------------------------
-- mode transformations

open import Agora.Order.Preorder
open import Agora.Order.Lattice

data Visibility : Set where
  vis : Visibility
  invis : Visibility

_â‹†_ : (v w : Visibility) -> Visibility
vis â‹† w = vis
invis â‹† w = w

module _ {P : ð’° _} {{_ : Preorder (â„“â‚€ , â„“â‚€ , â„“â‚€) on P }} where

  private variable
    U V : P

  data BaseModeTrans : {m n : Mode} (Î¼s Î·s : ModeHom P m n) -> Visibility -> Set where
    narrow : U â‰¤ V -> BaseModeTrans (`ï¼ ` U â¨¾ id) (`ï¼ ` V â¨¾ id) invis
    send : âˆ€ U -> BaseModeTrans id (`ï¼ ` U â¨¾ `[]` â¨¾ id) vis
    recv : âˆ€ U -> BaseModeTrans (`[]` â¨¾ `ï¼ ` U â¨¾ id) id vis

  data ModeTrans : {m n : Mode} (Î¼s Î·s : ModeHom P m n) -> Visibility -> Set where
    id : âˆ€{m n} -> {Î¼s : ModeHom P m n} -> ModeTrans Î¼s Î¼s invis
    base : âˆ€{m n v} -> {Î± Î² : ModeHom P m n}
          -> BaseModeTrans Î± Î² v
          -> ModeTrans Î± Î² v
    _â¨¾_ : âˆ€{m n k v w} -> {Î±â‚€ Î±â‚ : ModeHom P m n} -> {Î²â‚€ Î²â‚ : ModeHom P n k}
          -> ModeTrans Î±â‚€ Î±â‚ v
          -> ModeTrans Î²â‚€ Î²â‚ w
          -> ModeTrans (Î±â‚€ â—† Î²â‚€) (Î±â‚ â—† Î²â‚) (v â‹† w)

  module _ {{_ : isDecidablePreorder â€² P â€²}} where

    derive-ModeTrans : {m n : Mode} {v : Visibility} (Î¼s Î·s : ModeHom P m n)
                      -> Maybe (ModeTrans Î¼s Î·s v)
    derive-ModeTrans = {!!}
    -- derive-ModeTrans id id = yes id
    -- derive-ModeTrans id (x â¨¾ q) = nothing
    -- derive-ModeTrans (x â¨¾ p) id = nothing
    -- derive-ModeTrans (`ï¼ ` U â¨¾ p) (`ï¼ ` V â¨¾ q) with decide-â‰¤ U V
    -- ... | no x = nothing
    -- ... | yes Ï• with derive-ModeTrans p q
    -- ... | no x = nothing
    -- ... | yes Î¾ = yes (base (narrow Ï•) â¨¾ Î¾)
    -- derive-ModeTrans (`[]` â¨¾ p) (`[]` â¨¾ q) with derive-ModeTrans p q
    -- ... | nothing = nothing
    -- ... | yes Î¾ = yes (id â¨¾ Î¾)



