
{-# OPTIONS --allow-unsolved-metas #-}

module KamiTheory.Main.Dependent.Modality.Definition where

open import Agora.Conventions


------------------------------------------------------------------------
-- The new modality system

---------------------------------------------
-- modes

-- modes are "copies" of MLTT inside our type theory
data Mode : Set where
  ▲ : Mode -- the local mode
  ◯ : Mode -- the global mode


---------------------------------------------
-- modalities

-- modalities are morphisms between modes,
-- they are generated by the following two
-- base mode homs.
data BaseModeHom P : (m n : Mode) -> Set where
  `＠` : ∀(U : P) -> BaseModeHom P ▲ ◯
  `[]` : BaseModeHom P ◯ ▲

-- in general, modalities are concatenations
-- of base modalities
data ModeHom P : (m n : Mode) -> Set where
  id : ∀{m} -> ModeHom P m m
  _⨾_ : ∀{m n o} -> BaseModeHom P m n  -> ModeHom P n o -> ModeHom P m o

infixr 80 _⨾_

record Modality P : Set where
  constructor _↝_∋_
  field dom : Mode
  field cod : Mode
  field hom : ModeHom P dom cod

infixl 40 _↝_∋_

open Modality public

_◆_ : ∀{P m n k} -> ModeHom P m n -> ModeHom P n k -> ModeHom P m k
id ◆ q = q
(x ⨾ p) ◆ q = x ⨾ (p ◆ q)


---------------------------------------------
-- mode transformations

open import Agora.Order.Preorder
open import Agora.Order.Lattice

data Visibility : Set where
  vis : Visibility
  invis : Visibility

_⋆_ : (v w : Visibility) -> Visibility
vis ⋆ w = vis
invis ⋆ w = w

module _ {P : 𝒰 _} {{_ : Preorder (ℓ₀ , ℓ₀ , ℓ₀) on P }} where

  private variable
    U V : P

  data BaseModeTrans : {m n : Mode} (μs ηs : ModeHom P m n) -> Visibility -> Set where
    narrow : U ≤ V -> BaseModeTrans (`＠` U ⨾ id) (`＠` V ⨾ id) invis
    send : ∀ U -> BaseModeTrans id (`＠` U ⨾ `[]` ⨾ id) vis
    recv : ∀ U -> BaseModeTrans (`[]` ⨾ `＠` U ⨾ id) id vis

  data ModeTrans : {m n : Mode} (μs ηs : ModeHom P m n) -> Visibility -> Set where
    id : ∀{m n} -> {μs : ModeHom P m n} -> ModeTrans μs μs invis
    base : ∀{m n v} -> {α β : ModeHom P m n}
          -> BaseModeTrans α β v
          -> ModeTrans α β v
    _⨾_ : ∀{m n k v w} -> {α₀ α₁ : ModeHom P m n} -> {β₀ β₁ : ModeHom P n k}
          -> ModeTrans α₀ α₁ v
          -> ModeTrans β₀ β₁ w
          -> ModeTrans (α₀ ◆ β₀) (α₁ ◆ β₁) (v ⋆ w)

  module _ {{_ : isDecidablePreorder ′ P ′}} where

    derive-ModeTrans : {m n : Mode} {v : Visibility} (μs ηs : ModeHom P m n)
                      -> Maybe (ModeTrans μs ηs v)
    derive-ModeTrans = {!!}
    -- derive-ModeTrans id id = yes id
    -- derive-ModeTrans id (x ⨾ q) = nothing
    -- derive-ModeTrans (x ⨾ p) id = nothing
    -- derive-ModeTrans (`＠` U ⨾ p) (`＠` V ⨾ q) with decide-≤ U V
    -- ... | no x = nothing
    -- ... | yes ϕ with derive-ModeTrans p q
    -- ... | no x = nothing
    -- ... | yes ξ = yes (base (narrow ϕ) ⨾ ξ)
    -- derive-ModeTrans (`[]` ⨾ p) (`[]` ⨾ q) with derive-ModeTrans p q
    -- ... | nothing = nothing
    -- ... | yes ξ = yes (id ⨾ ξ)



