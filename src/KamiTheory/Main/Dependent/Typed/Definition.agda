
----------------------------------------------------------
--
-- Typing rules of the Kami language
--
-- This file contains the typing rules for terms and types. It
-- very closely follows the setup of MTT [1] (pages 108ff.), and differs only in
-- the fact that our representation of terms is *not* intrinsically
-- typed, and the substitution calculus works without typing
-- information - the required data is already part of the untyped
-- terms.
--
-- Apart from that, our representation of modalities is a mixture
-- between the informal and formal versions of MTT: our contexts
-- are merely lists of types with modality annotations, but a separate
-- list of the same size carries the "denominator", respectively
-- the context restriction data.
--
-- The file was originally taken from a project by Joakim √ñhman et al.,
-- but the typing rules themselves follow MTT.
--
-- -[1]: http://www.danielgratzer.com/papers/phd-thesis.pdf
--
----------------------------------------------------------
--
-- Original file by Joakim √ñhman et al.
-- See here: https://github.com/mr-ohman/logrel-mltt/blob/master/Definition/Untyped.agda
--
-- Original license:
-- ```
--   Copyright (c) 2016 Joakim √ñhman, Andrea Vezzosi, Andreas Abel
--   Permission is hereby granted, free of charge, to any person obtaining a copy
--   of this software and associated documentation files (the "Software"), to deal
--   in the Software without restriction, including without limitation the rights
--   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--   copies of the Software, and to permit persons to whom the Software is
--   furnished to do so, subject to the following conditions:

--   The above copyright notice and this permission notice shall be included in all
--   copies or substantial portions of the Software.

--   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--   SOFTWARE.
-- ```


{-# OPTIONS --allow-unsolved-metas --rewriting #-}

module KamiTheory.Main.Dependent.Typed.Definition where

open import Agora.Conventions hiding (_‚àô_ ; _‚à∑_ ; k ; const ; _‚à£_)

open import Data.Vec using ([] ; _‚à∑_ ; _++_ ; lookup) renaming (Vec to StdVec ; map to map-Vec)

open import KamiTheory.Basics hiding (typed)
open import KamiTheory.Main.Dependent.Untyped.Definition

open import KamiTheory.ThirdParty.logrel-mltt.Tools.Fin
open import KamiTheory.ThirdParty.logrel-mltt.Tools.Nat
open import KamiTheory.ThirdParty.logrel-mltt.Tools.Product

open import KamiTheory.Main.Generic.ModeSystem.2Graph.Definition
open import KamiTheory.Main.Generic.ModeSystem.ModeSystem.Definition hiding ([_])
open import KamiTheory.Main.Generic.ModeSystem.Modality
open import KamiTheory.Main.Generic.ModeSystem.Transition




module Judgements (P : ModeSystem ùëñ) where



  infixl 30 _‚àô_
  infix 30 Œ†‚±º_‚ñπ_
  -- infix 30 Œ£‚±º_‚ñπ_
  infixl 24 _‚àò‚±º_

  open Term

  private variable
    k l o q r mm nn : Mode P
    Œº : ModeHom P k l
    ŒΩ : ModeHom P o q
    Œ∑ : ModeHom P o q
    œâ : ModeHom P mm nn
    œÅ : ModeHom P mm nn

  data Restriction : (Mode P) -> ‚Ñï -> ùí∞ ùëñ where
    [] : Restriction k 0
    _‚à∑_ : ModeHom P k l -> Restriction l n -> Restriction k (suc n)

  private variable
    M : Restriction k n
    N : Restriction k n

  _‚Ü≥_ : ModeHom P l k -> Restriction k n -> Restriction l n
  Œº ‚Ü≥ [] = []
  Œº ‚Ü≥ (x ‚à∑ M) = Œº ‚óÜ x ‚à∑ M

  postulate
    comp-‚Ü≥ : (ŒΩ ‚óÜ Œº ‚Ü≥ M) ‚â° ŒΩ ‚Ü≥ Œº ‚Ü≥ M
    id-‚Ü≥ : (id ‚Ü≥ M) ‚â° M

  {-# REWRITE comp-‚Ü≥ #-}
  {-# REWRITE id-‚Ü≥ #-}


  data Target (n : ‚Ñï) : ùí∞ ùëñ where
    _‚à•_ : Term P n -> Restriction k n -> Target n

  infix 21 _‚à•_

  infixr 22 _‚Ü≥_

  pattern _‚à•[_]_ T k M = _‚à•_ {k = k} T M


  private variable
    Œæ Œæ‚ÇÄ Œæ‚ÇÅ : Term P n -- Transitions
    Œì  : Con (Entry P) n
    A B : Term P n
    C D : Term P n
    a b : Term P n
    X Y : Term P n
    L K : Term P n
    E F : Entry P n
    t s : Term P n
    f g : Term P n
    x : Fin n


  wk1-Entry : Entry P n -> Entry P (suc n)
  wk1-Entry (A // Œº) = wk1 A // Œº

  -- Well-typed variables
  data _‚à∂_‚áí_‚àà_‚à•_ : (x : Fin n) (E : Entry P n) (Œ∑ : ModeHom P k l) (Œì : Con (Entry P) n) (M : Restriction k n) ‚Üí ùí∞ ùëñ where
    zero :          x0 ‚à∂ wk1-Entry ((A) / œâ) ‚áí Œ∑ ‚àà (Œì ‚àô (A / œâ)) ‚à• (Œ∑ ‚à∑ M)
    suc  : (h : x ‚à∂ (A / œâ) ‚áí Œ∑ ‚àà Œì ‚à• M) ‚Üí (x +1) ‚à∂ wk1-Entry ((A) / œâ) ‚áí (Œº ‚óÜ Œ∑) ‚àà (Œì ‚àô F) ‚à• (Œº ‚à∑ M)



  ----------------------------------------------------------
  -- The judgements for contexts, types, terms and equality have to be stated mutual-recursively.
  --
  -- well-formed contexts
  data ‚ä¢Ctx_‚à•_ : Con (Entry P) n ‚Üí Restriction k n ‚Üí ùí∞ ùëñ

  -- well-formed types
  data _‚ä¢Type_ (Œì : Con (Entry P) n) : Target n -> ùí∞ ùëñ

  -- well-formed terms
  data _‚ä¢_‚à∂_ (Œì : Con (Entry P) n) : Term P n ‚Üí Target n ‚Üí ùí∞ ùëñ

  -- equality for types
  data _‚ä¢Type_Ôºù_‚à•_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n -> Restriction k n ‚Üí ùí∞ ùëñ

  -- equality for terms
  data _‚ä¢_Ôºù_‚à∂_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n ‚Üí Target n ‚Üí ùí∞ ùëñ


  ----------------------------------------------------------
  -- Here come the definitions:

  -------------------
  -- Well-formed context
  --
  data ‚ä¢Ctx_‚à•_ where

    -- The empty context is well-formed.
    Œµ   : ‚ä¢Ctx_‚à•_ {k = k} Œµ []

    -- The rule for context extension requires that if
    -- the context is to be extended by a type `A` with modality
    -- `Œº`, then it has to be well-formed with respect to a
    -- `Œº`-restricted context.
    _‚àô_ : ‚àÄ{M : Restriction o n}
        -> ‚ä¢Ctx Œì ‚à• M
        -> ‚àÄ{Œ∑ : ModeHom P q o}
        -> ‚àÄ{Œº : ModeHom P l o}
        ‚Üí Œì ‚ä¢Type A ‚à• Œº ‚Ü≥ M
        ‚Üí ‚ä¢Ctx Œì ‚àô (A / Œº) ‚à• (Œ∑ ‚à∑ M)


  -------------------
  -- Well-formed types
  --
  data _‚ä¢Type_ Œì where
    -- The rules for standard data types such as bools or naturals
    -- are valid under any context restriction `M`. They do require
    -- the context to be well-formed, however.
    NN‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢Type (NN ‚à• M)
    BB‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢Type (BB ‚à• M)
    Empty‚±º : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢Type (Empty ‚à• M)
    Unit‚±º  : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢Type (Unit ‚à• M)
    UU‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢Type (UU ‚à• M)

    -- A vector, having a type parameter, does not require anything
    -- for the context. Otherwise it is again valid under any context restriction.
    Vec‚±º   : Œì ‚ä¢Type (A ‚à• M) ‚Üí Œì ‚ä¢ t ‚à∂ NN ‚à• M  ‚Üí Œì ‚ä¢Type (Vec A t ‚à• M)

    -- Sigma types are standard. They do not have any interactions with context
    -- restrictions, and require their first type parameter to be under an
    -- identity modality. This follows MTT, but might change in the future
    -- to allow other modalities as well.
    Œ£‚±º_‚ñπ_  : {M : Restriction k _}
            ‚Üí Œì ‚ä¢Type (A ‚à• M)
            ‚Üí Œì ‚àô (A // (k ‚Üù k ‚àã id)) ‚ä¢Type (B ‚à• (id ‚à∑ M))
            ‚Üí Œì ‚ä¢Type ((Œ£ A // incl (k ‚Üù k ‚àã id) ‚ñπ B) ‚à• M)

    -- Pi types follow MTT: the bound variable is allowed to be under a
    -- non-identity modality `Œº`, thus the type has to be well-formed after
    -- additionally restricting the context by `Œº`.
    Œ†‚±º_‚ñπ_  : Œì ‚ä¢Type (A ‚à• Œº ‚Ü≥ M)
              ‚Üí Œì ‚àô (A / Œº) ‚ä¢Type (B ‚à• (id ‚à∑ M))
              ‚Üí Œì ‚ä¢Type ((Œ† A / Œº ‚ñπ B) ‚à• M)


    -- Universes: The rule is standard, if a term is of type universe,
    -- we can conclude that it is actually a type.
    Univ‚±º : Œì ‚ä¢ X ‚à∂ UU ‚à• M ‚Üí Œì ‚ä¢Type (X ‚à• M)

    -- Modal types: Similar with Pi types, a type under modality annotation
    -- has to be well-formed after restricting the context.
    Modal‚±º : Œì ‚ä¢Type (A ‚à• (Œ∑ ‚Ü≥ M)) -> Œì ‚ä¢Type ‚ü® A ‚à£ Œ∑ ‚ü© ‚à• M



  -------------------
  -- Well-formed term of a type
  data _‚ä¢_‚à∂_ Œì where

    -- For every typing rule, there is a similar term rule,
    -- which describes the elements of the universe:
    NN‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢ NN ‚à∂ UU ‚à• M
    BB‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢ BB ‚à∂ UU ‚à• M
    UU‚±º    : {{ŒìP : isTrue (‚ä¢Ctx Œì ‚à• M)}} ‚Üí Œì ‚ä¢ UU ‚à∂ UU ‚à• M
    Vec‚±º   : Œì ‚ä¢ A ‚à∂ UU ‚à• M ‚Üí Œì ‚ä¢ t ‚à∂ NN ‚à• M  ‚Üí Œì ‚ä¢ Vec A t ‚à∂ UU ‚à• M
    Œ†‚±º_‚ñπ_  : Œì ‚ä¢ A ‚à∂ UU ‚à• Œº ‚Ü≥ M
              ‚Üí Œì ‚àô (A / Œº) ‚ä¢ B ‚à∂ UU ‚à• (id ‚à∑ M)
              ‚Üí Œì ‚ä¢ (Œ† A / Œº ‚ñπ B) ‚à∂ UU ‚à• M
    Œ£‚±º_‚ñπ_  : {M : Restriction k _}
            ‚Üí Œì ‚ä¢ A ‚à∂ UU ‚à• M
            ‚Üí Œì ‚àô (A // (k ‚Üù k ‚àã id)) ‚ä¢ B ‚à∂ UU ‚à• (id ‚à∑ M)
            ‚Üí Œì ‚ä¢ (Œ£ A // incl (k ‚Üù k ‚àã id) ‚ñπ B) ‚à∂ UU ‚à• M
    Modal‚±º : Œì ‚ä¢ A ‚à∂ UU ‚à• (Œ∑ ‚Ü≥ M) -> Œì ‚ä¢ ‚ü® A ‚à£ Œ∑ ‚ü© ‚à∂ UU ‚à• M


    -- The rules for introducing and eliminating modality types
    -- are the same as in MTT
    --
    -- A type X under modality Œ∑ can be introduced if X can
    -- be derived in an Œ∑-restricted context.
    mod‚±º : Œì ‚ä¢ t ‚à∂ X ‚à• (Œ∑ ‚Ü≥ M) -> Œì ‚ä¢ mod[ Œ∑ ] t ‚à∂ ‚ü® X ‚à£ Œ∑ ‚ü© ‚à• M
    --
    -- The elimination rule is inverse, a modal type can be eliminated
    -- by assuming a value under a modality annotation. Note that
    -- we also support a "framing modality" Œº.
    letunmod‚±º[_]_into_by_ :
                 ‚àÄ (Œº : ModeHom P k l)
              -> Œì ‚ä¢ t ‚à∂ ‚ü® X ‚à£ Œ∑ ‚ü© ‚à• Œº ‚Ü≥ M
              -> Œì ‚àô (‚ü® X ‚à£ Œ∑ ‚ü© / Œº) ‚ä¢Type Y ‚à• (id ‚à∑ M)
              -> Œì ‚àô (X / (Œ∑ ‚óÜ Œº)) ‚ä¢ s ‚à∂ (Y [ mod[ Œº ] (var x0 id) ]‚Üë) ‚à• (id ‚à∑ M)
              -> Œì ‚ä¢ letunmod[ Œº ] t into Y by s ‚à∂ (Y [ t ]) ‚à• M




    -- Transformations between modehoms (transitions)
    --
    --
    -- transform‚±º : ‚àÄ (Œ∂ : ModalityTrans P vis (_ ‚Üù _ ‚àã Œº) (_ ‚Üù _ ‚àã Œ∑))
    --              -> Œì ‚ä¢ t ‚à∂ A / Œº
    --              -> Œì ‚ä¢ transform (incl Œ∂) t ‚à∂ A / Œ∑




    -- The variable rule is special, and is the main interaction point between
    -- the system of modalities and the terms of the type theory:
    -- Variables are annotated with mode-transformations, which denote transitions
    -- between different modalities. These transitions commute with all terms,
    -- and thus only have to be recorded at those nodes of the term tree, whose
    -- value is unknown: the variables.
    var       : ‚àÄ {A x}
              -- -> {{ŒìP : isTrue (‚ä¢Ctx Œì)}}
              ‚Üí x ‚à∂ (A // (k ‚Üù l ‚àã Œº)) ‚áí Œ∑ ‚àà Œì ‚à• M
              ‚Üí (Œ∂ : ModeTrans* P all (Œº) (Œ∑))
              ‚Üí Œì ‚ä¢ (var x (incl (_ ‚áí _ ‚àã Œ∂))) ‚à∂ A ^[ _ ‚áí _ ‚àã Œ∂ ] ‚à• M


    -- The lambda rule allows to move a variable with modality annotation into
    -- the context.
    lam‚±º_‚Ü¶_      : ‚àÄ {t}
              ‚Üí Œì ‚ä¢Type (A ‚à• Œ∑ ‚Ü≥ M)
              ‚Üí Œì ‚àô (A / Œ∑) ‚ä¢ t ‚à∂ B ‚à• (id ‚à∑ M)
              ‚Üí Œì ‚ä¢ lam‚Ü¶ t ‚à∂ (Œ† A / Œ∑ ‚ñπ B) ‚à• M

    -- The application rule does the reverse - to apply a function whose variable
    -- is under Œ∑, the argument has to be well-formed under Œ∑-restriction.
    _‚àò‚±º_      : ‚àÄ {g a}
              ‚Üí Œì ‚ä¢ g ‚à∂ (Œ† A / Œ∑ ‚ñπ B) ‚à• M
              ‚Üí Œì ‚ä¢ a ‚à∂ A ‚à• (Œ∑ ‚Ü≥ M)
              ‚Üí Œì ‚ä¢ g ‚àò[ Œ∑ ] a ‚à∂ B [ untransform-Term a ] ‚à• M

{-

    intro‚±ºŒ£_‚ñπ_by_,_  : ‚àÄ {A B} -> ‚àÄ{t u}
              -> {Œº : ModeHom P k l}
              ‚Üí (Œì ‚ä¢Type (A / Œº))
              ‚Üí (Œì ‚àô (A / Œº) ‚ä¢Type B / Œº)
              ‚Üí Œì ‚ä¢ t ‚à∂ A / Œº
              ‚Üí Œì ‚ä¢ u ‚à∂ B [ t ] / Œº
              ‚Üí Œì ‚ä¢ t ,, u ‚à∂ (Œ£ A // incl (k ‚Üù k ‚àã id) ‚ñπ B) / Œº

    fst‚±º      : ‚àÄ {A B} -> ‚àÄ{t}
              -> {Œº : ModeHom P k l}
              -- ‚Üí {{_ : isTrue (Œì ‚ä¢Type (A / Œº))}}
              -- ‚Üí {{_ : isTrue (Œì ‚àô (A / Œº) ‚ä¢Sort B)}}
              ‚Üí Œì ‚ä¢ t ‚à∂ (Œ£ A // incl (k ‚Üù k ‚àã id) ‚ñπ B) / Œº
              ‚Üí Œì ‚ä¢ fst‚Çú t ‚à∂ A / Œº

    snd‚±º      : ‚àÄ {A B} -> ‚àÄ{t}
              -> {Œº : ModeHom P k l}
              -- ‚Üí {{_ : isTrue (Œì ‚ä¢Type (A / Œº))}}
              -- ‚Üí {{_ : isTrue (Œì ‚àô (A / Œº) ‚ä¢Sort B)}}
              ‚Üí Œì ‚ä¢ t ‚à∂ (Œ£ A // incl (k ‚Üù k ‚àã id) ‚ñπ B) / Œº
              ‚Üí Œì ‚ä¢ snd‚Çú t ‚à∂ B [ fst‚Çú t ] / Œº
              -}


    -- Introduction and elimination for booleans, standard.
    false‚±º     : -- {{ŒìP : isTrue (‚ä¢Ctx Œì)}} ‚Üí
                 Œì ‚ä¢ false‚Çú ‚à∂ BB  ‚à• M

    true‚±º     : -- {{ŒìP : isTrue (‚ä¢Ctx Œì)}} ‚Üí
                Œì ‚ä¢ true‚Çú ‚à∂ BB  ‚à• M

    -- Note that we only allow elimination if the value is
    -- under identity modality.
    boolrec‚±º_into_false:_true:_   : ‚àÄ {G}
              ‚Üí Œì       ‚ä¢ b ‚à∂ BB  ‚à• M
              ‚Üí Œì ‚àô (BB // _ ‚Üù k ‚àã id) ‚ä¢Type G ‚à• (_‚à∑_ {k = k} id M)
              ‚Üí Œì       ‚ä¢ f ‚à∂ G [ false‚Çú ]  ‚à• M
              ‚Üí Œì       ‚ä¢ t ‚à∂ G [ true‚Çú ]  ‚à• M
              ‚Üí Œì       ‚ä¢ boolrec b into G false: f true: t ‚à∂ G [ b ]  ‚à• M

    -- Introduction and elimination for natural numbers, standard.
    zero‚±º     : --  {{ŒìP : isTrue (‚ä¢Ctx Œì)}} ‚Üí
                 Œì ‚ä¢ zero‚Çú ‚à∂ NN  ‚à• M

    suc‚±º      : ‚àÄ {n}
              ‚Üí Œì ‚ä¢      n ‚à∂ NN  ‚à• M
              ‚Üí Œì ‚ä¢ suc‚Çú n ‚à∂ NN  ‚à• M

    natrec‚±º_into_zero:_suc:_   : ‚àÄ {G s z n}
              ‚Üí Œì       ‚ä¢ n ‚à∂ NN  ‚à• M
              ‚Üí Œì ‚àô (NN // _ ‚Üù k ‚àã id) ‚ä¢Type (G ‚à•[ k ] (id ‚à∑ M))
              ‚Üí Œì       ‚ä¢ z ‚à∂ G [ zero‚Çú ]  ‚à• M
              ‚Üí Œì       ‚ä¢ s ‚à∂ (Œ† NN // incl (k ‚Üù _ ‚àã id) ‚ñπ (G // incl (k ‚Üù _ ‚àã id) ‚ñπ‚ñπ (G [ suc‚Çú (var x0 id) ]‚Üë)))  ‚à• M
              ‚Üí Œì       ‚ä¢ natrec G z s n ‚à∂ G [ n ]  ‚à• M


    -- Introduction and elimination of vectors.
    nil‚±º      : ‚àÄ {A}
              ‚Üí Œì ‚ä¢ nil‚Çú ‚à∂ Vec A zero‚Çú  ‚à• M

    cons‚±º     : ‚àÄ {A v vs n}
              ‚Üí Œì ‚ä¢         v ‚à∂ A  ‚à• M
              ‚Üí Œì ‚ä¢        vs ‚à∂ Vec A n  ‚à• M
              ‚Üí Œì ‚ä¢ cons‚Çú v vs ‚à∂ Vec A (suc‚Çú n)  ‚à• M

    head‚±º     : ‚àÄ {A vs n}
              ‚Üí Œì ‚ä¢ vs ‚à∂ Vec A (suc‚Çú n)  ‚à• M
              ‚Üí Œì ‚ä¢ head‚Çú vs ‚à∂ A  ‚à• M

    tail‚±º     : ‚àÄ {A vs n}
              ‚Üí Œì ‚ä¢ vs ‚à∂ Vec A (suc‚Çú n)  ‚à• M
              ‚Üí Œì ‚ä¢ tail‚Çú  vs ‚à∂ Vec A n  ‚à• M


    -- The conversion rule: If it can be shown that two types A and B are equal,
    -- then terms of type A can be converted into terms of type B.
    conv      : ‚àÄ {t A B}
              ‚Üí Œì ‚ä¢Type A Ôºù B ‚à• M
              ‚Üí Œì ‚ä¢ t ‚à∂ A ‚à• M
              ‚Üí Œì ‚ä¢ t ‚à∂ B ‚à• M


  pattern letunmod‚±º_into_by_ t G s = letunmod‚±º[ id ] t into G by  s



  -- Type equality
  data _‚ä¢Type_Ôºù_‚à•_ Œì where
    univ   : ‚àÄ {A B}
          ‚Üí Œì ‚ä¢ A Ôºù B ‚à∂ UU ‚à• M
          ‚Üí Œì ‚ä¢Type A Ôºù B ‚à• M

    refl‚Çë   : ‚àÄ {A}
          ‚Üí Œì ‚ä¢Type A ‚à• M
          ‚Üí Œì ‚ä¢Type A Ôºù A ‚à• M

    sym‚Çë    : ‚àÄ {A B}
          ‚Üí Œì ‚ä¢Type A Ôºù B ‚à• M
          ‚Üí Œì ‚ä¢Type B Ôºù A ‚à• M

    trans‚Çë  : ‚àÄ {A B C}
          ‚Üí Œì ‚ä¢Type A Ôºù B ‚à• M
          ‚Üí Œì ‚ä¢Type B Ôºù C ‚à• M
          ‚Üí Œì ‚ä¢Type A Ôºù C ‚à• M

    Œ†-cong :
             Œì     ‚ä¢Type (A ‚à• M)
          ‚Üí Œì     ‚ä¢Type A Ôºù B ‚à• M
          ‚Üí Œì ‚àô (A / Œº) ‚ä¢Type C Ôºù D ‚à• (Œ∑ ‚à∑ N)
          ‚Üí Œì     ‚ä¢Type (Œ† A / Œº ‚ñπ C) Ôºù (Œ† B / Œº ‚ñπ D) ‚à• N

    Œ£-cong :
             Œì     ‚ä¢Type (A ‚à• M)
          ‚Üí Œì     ‚ä¢Type A Ôºù B ‚à• M
          ‚Üí Œì ‚àô (A / Œº) ‚ä¢Type C Ôºù D ‚à• (Œ∑ ‚à∑ N)
          ‚Üí Œì     ‚ä¢Type (Œ£ A / Œº ‚ñπ C) Ôºù (Œ£ B / Œº ‚ñπ D) ‚à• N


  -- Term equality
  data _‚ä¢_Ôºù_‚à∂_ Œì where
    refl‚Çë          : ‚àÄ {t A}
                  ‚Üí Œì ‚ä¢ t ‚à∂ A
                  ‚Üí Œì ‚ä¢ t Ôºù t ‚à∂ A


  --     sym           : ‚àÄ {t u A}
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù u ‚à∂ A
  --                   ‚Üí Œì ‚ä¢Sort u Ôºù t ‚à∂ A
  --     trans         : ‚àÄ {t u r A}
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù u ‚à∂ A
  --                   ‚Üí Œì ‚ä¢Sort u Ôºù r ‚à∂ A
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù r ‚à∂ A
  --     conv          : ‚àÄ {A B t u}
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù u ‚à∂ A
  --                   ‚Üí Œì ‚ä¢Sort A Ôºù B
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù u ‚à∂ B
  --     Œ†-cong        : ‚àÄ {E F G H}
  --                   ‚Üí Œì     ‚ä¢ F
  --                   ‚Üí Œì     ‚ä¢ F Ôºù H       ‚à∂ U
  --                   ‚Üí Œì ‚àô F ‚ä¢ G Ôºù E       ‚à∂ U
  --                   ‚Üí Œì     ‚ä¢ Œ† F ‚ñπ G Ôºù Œ† H ‚ñπ E ‚à∂ U
  --     Œ£-cong        : ‚àÄ {E F G H}
  --                   ‚Üí Œì     ‚ä¢ F
  --                   ‚Üí Œì     ‚ä¢ F Ôºù H       ‚à∂ U
  --                   ‚Üí Œì ‚àô F ‚ä¢ G Ôºù E       ‚à∂ U
  --                   ‚Üí Œì     ‚ä¢ Œ£ F ‚ñπ G Ôºù Œ£ H ‚ñπ E ‚à∂ U
  --     app-cong      : ‚àÄ {a b f g F G}
  --                   ‚Üí Œì ‚ä¢Sort f Ôºù g ‚à∂ Œ† F ‚ñπ G
  --                   ‚Üí Œì ‚ä¢Sort a Ôºù b ‚à∂ F
  --                   ‚Üí Œì ‚ä¢Sort f ‚àò a Ôºù g ‚àò b ‚à∂ G [ a ]

    Œ≤-red         : ‚àÄ {a t F G}
                  ‚Üí Œì     ‚ä¢Type F ‚à• (Œ∑ ‚Ü≥ M)
                  ‚Üí Œì ‚àô (F / Œ∑) ‚ä¢ t ‚à∂ G ‚à• (id ‚à∑ M)
                  ‚Üí Œì     ‚ä¢ a ‚à∂ F ‚à• (Œ∑ ‚Ü≥ M)
                  ‚Üí Œì     ‚ä¢ (lam‚Ü¶ t) ‚àò[ Œ∑ ] a Ôºù t [ a ] ‚à∂ G [ a ] ‚à• M

{-
  --     Œ∑-eq          : ‚àÄ {f g F G}
  --                   ‚Üí Œì     ‚ä¢ F
  --                   ‚Üí Œì     ‚ä¢ f ‚à∂ Œ† F ‚ñπ G
  --                   ‚Üí Œì     ‚ä¢ g ‚à∂ Œ† F ‚ñπ G
  --                   ‚Üí Œì ‚àô F ‚ä¢ wk1 f ‚àò var x0 Ôºù wk1 g ‚àò var x0 ‚à∂ G
  --                   ‚Üí Œì     ‚ä¢ f Ôºù g ‚à∂ Œ† F ‚ñπ G
  --     fst-cong      : ‚àÄ {t t' F G}
  --                   ‚Üí Œì ‚ä¢Sort F
  --                   ‚Üí Œì ‚àô F ‚ä¢ G
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù t' ‚à∂ Œ£ F ‚ñπ G
  --                   ‚Üí Œì ‚ä¢Sort fst t Ôºù fst t' ‚à∂ F
  --     snd-cong      : ‚àÄ {t t' F G}
  --                   ‚Üí Œì ‚ä¢Sort F
  --                   ‚Üí Œì ‚àô F ‚ä¢ G
  --                   ‚Üí Œì ‚ä¢Sort t Ôºù t' ‚à∂ Œ£ F ‚ñπ G
  --                   ‚Üí Œì ‚ä¢Sort snd t Ôºù snd t' ‚à∂ G [ fst t ]
  --     Œ£-Œ≤‚ÇÅ          : ‚àÄ {F G t u}
  --                   ‚Üí Œì ‚ä¢Sort F
  --                   ‚Üí Œì ‚àô F ‚ä¢ G
  --                   ‚Üí Œì ‚ä¢Sort t ‚à∂ F
  --                   ‚Üí Œì ‚ä¢Sort u ‚à∂ G [ t ]
  --                   ‚Üí Œì ‚ä¢Sort fst (prod t u) ‚â° t ‚à∂ F
  --     Œ£-Œ≤‚ÇÇ          : ‚àÄ {F G t u}
  --                   ‚Üí Œì ‚ä¢Sort F
  --                   ‚Üí Œì ‚àô F ‚ä¢ G
  --                   ‚Üí Œì ‚ä¢Sort t ‚à∂ F
  --                   ‚Üí Œì ‚ä¢Sort u ‚à∂ G [ t ]
  --                   ‚Üí Œì ‚ä¢Sort snd (prod t u) ‚â° u ‚à∂ G [ fst (prod t u) ]
  --     Œ£-Œ∑           : ‚àÄ {p r F G}
  --                   ‚Üí Œì ‚ä¢Sort F
  --                   ‚Üí Œì ‚àô F ‚ä¢ G
  --                   ‚Üí Œì ‚ä¢Sort p ‚à∂ Œ£ F ‚ñπ G
  --                   ‚Üí Œì ‚ä¢Sort r ‚à∂ Œ£ F ‚ñπ G
  --                   ‚Üí Œì ‚ä¢Sort fst p ‚â° fst r ‚à∂ F
  --                   ‚Üí Œì ‚ä¢Sort snd p ‚â° snd r ‚à∂ G [ fst p ]
  --                   ‚Üí Œì ‚ä¢Sort p ‚â° r ‚à∂ Œ£ F ‚ñπ G
  --     suc-cong      : ‚àÄ {m n}
  --                   ‚Üí Œì ‚ä¢Sort m ‚â° n ‚à∂ ‚Ñï
  --                   ‚Üí Œì ‚ä¢Sort suc m ‚â° suc n ‚à∂ ‚Ñï
  --     natrec-cong   : ‚àÄ {z z‚Ä≤ s s‚Ä≤ n n‚Ä≤ F F‚Ä≤}
  --                   ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F ‚â° F‚Ä≤
  --                   ‚Üí Œì     ‚ä¢ z ‚â° z‚Ä≤ ‚à∂ F [ zero ]
  --                   ‚Üí Œì     ‚ä¢ s ‚â° s‚Ä≤ ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                   ‚Üí Œì     ‚ä¢ n ‚â° n‚Ä≤ ‚à∂ ‚Ñï
  --                   ‚Üí Œì     ‚ä¢ natrec F z s n ‚â° natrec F‚Ä≤ z‚Ä≤ s‚Ä≤ n‚Ä≤ ‚à∂ F [ n ]
  --     natrec-zero   : ‚àÄ {z s F}
  --                   ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F
  --                   ‚Üí Œì     ‚ä¢ z ‚à∂ F [ zero ]
  --                   ‚Üí Œì     ‚ä¢ s ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                   ‚Üí Œì     ‚ä¢ natrec F z s zero ‚â° z ‚à∂ F [ zero ]
  --     natrec-suc    : ‚àÄ {n z s F}
  --                   ‚Üí Œì     ‚ä¢ n ‚à∂ ‚Ñï
  --                   ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F
  --                   ‚Üí Œì     ‚ä¢ z ‚à∂ F [ zero ]
  --                   ‚Üí Œì     ‚ä¢ s ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                   ‚Üí Œì     ‚ä¢ natrec F z s (suc n) ‚â° (s ‚àò n) ‚àò (natrec F z s n)
  --                           ‚à∂ F [ suc n ]
  --     Emptyrec-cong : ‚àÄ {A A' e e'}
  --                   ‚Üí Œì ‚ä¢Sort A ‚â° A'
  --                   ‚Üí Œì ‚ä¢Sort e ‚â° e' ‚à∂ Empty
  --                   ‚Üí Œì ‚ä¢Sort Emptyrec A e ‚â° Emptyrec A' e' ‚à∂ A
  --     Œ∑-unit        : ‚àÄ {e e'}
  --                   ‚Üí Œì ‚ä¢Sort e ‚à∂ Unit
  --                   ‚Üí Œì ‚ä¢Sort e' ‚à∂ Unit
  --                   ‚Üí Œì ‚ä¢Sort e ‚â° e' ‚à∂ Unit

{-
{-

  -- -- Term reduction
  -- data _‚ä¢_‚áí_‚à∂_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n ‚Üí Term P n ‚Üí Set where
  --   conv           : ‚àÄ {A B t u}
  --                 ‚Üí Œì ‚ä¢Sort t ‚áí u ‚à∂ A
  --                 ‚Üí Œì ‚ä¢Sort A ‚â° B
  --                 ‚Üí Œì ‚ä¢Sort t ‚áí u ‚à∂ B
  --   app-subst      : ‚àÄ {A B t u a}
  --                 ‚Üí Œì ‚ä¢Sort t ‚áí u ‚à∂ Œ† A ‚ñπ B
  --                 ‚Üí Œì ‚ä¢Sort a ‚à∂ A
  --                 ‚Üí Œì ‚ä¢Sort t ‚àò a ‚áí u ‚àò a ‚à∂ B [ a ]
  --   Œ≤-red          : ‚àÄ {A B a t}
  --                 ‚Üí Œì     ‚ä¢ A
  --                 ‚Üí Œì ‚àô A ‚ä¢ t ‚à∂ B
  --                 ‚Üí Œì     ‚ä¢ a ‚à∂ A
  --                 ‚Üí Œì     ‚ä¢ (lam t) ‚àò a ‚áí t [ a ] ‚à∂ B [ a ]
  --   fst-subst      : ‚àÄ {t t' F G}
  --                 ‚Üí Œì ‚ä¢Sort F
  --                 ‚Üí Œì ‚àô F ‚ä¢ G
  --                 ‚Üí Œì ‚ä¢Sort t ‚áí t' ‚à∂ Œ£ F ‚ñπ G
  --                 ‚Üí Œì ‚ä¢Sort fst t ‚áí fst t' ‚à∂ F
  --   snd-subst      : ‚àÄ {t t' F G}
  --                 ‚Üí Œì ‚ä¢Sort F
  --                 ‚Üí Œì ‚àô F ‚ä¢ G
  --                 ‚Üí Œì ‚ä¢Sort t ‚áí t' ‚à∂ Œ£ F ‚ñπ G
  --                 ‚Üí Œì ‚ä¢Sort snd t ‚áí snd t' ‚à∂ G [ fst t ]
  --   Œ£-Œ≤‚ÇÅ           : ‚àÄ {F G t u}
  --                 ‚Üí Œì ‚ä¢Sort F
  --                 ‚Üí Œì ‚àô F ‚ä¢ G
  --                 ‚Üí Œì ‚ä¢Sort t ‚à∂ F
  --                 ‚Üí Œì ‚ä¢Sort u ‚à∂ G [ t ]
  --                 ‚Üí Œì ‚ä¢Sort fst (prod t u) ‚áí t ‚à∂ F
  --   Œ£-Œ≤‚ÇÇ           : ‚àÄ {F G t u}
  --                 ‚Üí Œì ‚ä¢Sort F
  --                 ‚Üí Œì ‚àô F ‚ä¢ G
  --                 ‚Üí Œì ‚ä¢Sort t ‚à∂ F
  --                 ‚Üí Œì ‚ä¢Sort u ‚à∂ G [ t ]
  --                 -- TODO(WN): Prove that ùîç ‚à∂ G [ t ] is admissible
  --                 ‚Üí Œì ‚ä¢Sort snd (prod t u) ‚áí u ‚à∂ G [ fst (prod t u) ]
  --   natrec-subst   : ‚àÄ {z s n n‚Ä≤ F}
  --                 ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F
  --                 ‚Üí Œì     ‚ä¢ z ‚à∂ F [ zero ]
  --                 ‚Üí Œì     ‚ä¢ s ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                 ‚Üí Œì     ‚ä¢ n ‚áí n‚Ä≤ ‚à∂ ‚Ñï
  --                 ‚Üí Œì     ‚ä¢ natrec F z s n ‚áí natrec F z s n‚Ä≤ ‚à∂ F [ n ]
  --   natrec-zero    : ‚àÄ {z s F}
  --                 ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F
  --                 ‚Üí Œì     ‚ä¢ z ‚à∂ F [ zero ]
  --                 ‚Üí Œì     ‚ä¢ s ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                 ‚Üí Œì     ‚ä¢ natrec F z s zero ‚áí z ‚à∂ F [ zero ]
  --   natrec-suc     : ‚àÄ {n z s F}
  --                 ‚Üí Œì     ‚ä¢ n ‚à∂ ‚Ñï
  --                 ‚Üí Œì ‚àô ‚Ñï ‚ä¢ F
  --                 ‚Üí Œì     ‚ä¢ z ‚à∂ F [ zero ]
  --                 ‚Üí Œì     ‚ä¢ s ‚à∂ Œ† ‚Ñï ‚ñπ (F ‚ñπ‚ñπ F [ suc (var x0) ]‚Üë)
  --                 ‚Üí Œì     ‚ä¢ natrec F z s (suc n) ‚áí (s ‚àò n) ‚àò (natrec F z s n) ‚à∂ F [ suc n ]
  --   Emptyrec-subst : ‚àÄ {n n‚Ä≤ A}
  --                 ‚Üí Œì ‚ä¢Sort A
  --                 ‚Üí Œì     ‚ä¢ n ‚áí n‚Ä≤ ‚à∂ Empty
  --                 ‚Üí Œì     ‚ä¢ Emptyrec A n ‚áí Emptyrec A n‚Ä≤ ‚à∂ A

  -- Type reduction
  data _‚ä¢_‚áí_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n ‚Üí Set where
    univ : ‚àÄ {A B}
        ‚Üí Œì ‚ä¢Sort A ‚áí B ‚à∂ U
        ‚Üí Œì ‚ä¢Sort A ‚áí B

  -- Term reduction closure
  data _‚ä¢_‚áí*_‚à∂_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n ‚Üí Term P n ‚Üí Set where
    id  : ‚àÄ {A t}
        ‚Üí Œì ‚ä¢Sort t ‚à∂ A
        ‚Üí Œì ‚ä¢Sort t ‚áí* t ‚à∂ A
    _‚á®_ : ‚àÄ {A t t‚Ä≤ u}
        ‚Üí Œì ‚ä¢Sort t  ‚áí  t‚Ä≤ ‚à∂ A
        ‚Üí Œì ‚ä¢Sort t‚Ä≤ ‚áí* u  ‚à∂ A
        ‚Üí Œì ‚ä¢Sort t  ‚áí* u  ‚à∂ A

  -- Type reduction closure
  data _‚ä¢_‚áí*_ (Œì : Con (Entry P) n) : Term P n ‚Üí Term P n ‚Üí Set where
    id  : ‚àÄ {A}
        ‚Üí Œì ‚ä¢Sort A
        ‚Üí Œì ‚ä¢Sort A ‚áí* A
    _‚á®_ : ‚àÄ {A A‚Ä≤ B}
        ‚Üí Œì ‚ä¢Sort A  ‚áí  A‚Ä≤
        ‚Üí Œì ‚ä¢Sort A‚Ä≤ ‚áí* B
        ‚Üí Œì ‚ä¢Sort A  ‚áí* B

  -- Type reduction to whnf
  _‚ä¢_‚Üò_ : (Œì : Con (Entry P) n) ‚Üí Term P n ‚Üí Term P n ‚Üí Set
  Œì ‚ä¢Sort A ‚Üò B = Œì ‚ä¢Sort A ‚áí* B √ó Whnf B

  -- Term reduction to whnf
  _‚ä¢_‚Üò_‚à∂_ : (Œì : Con (Entry P) n) ‚Üí Term P n ‚Üí Term P n ‚Üí Term P n ‚Üí Set
  Œì ‚ä¢Sort t ‚Üò u ‚à∂ A = Œì ‚ä¢Sort t ‚áí* u ‚à∂ A √ó Whnf u

  -- Type equality with well-formed types
  _‚ä¢_:‚â°:_ : (Œì : Con (Entry P) n) ‚Üí Term P n ‚Üí Term P n ‚Üí Set
  Œì ‚ä¢Sort A :‚â°: B = Œì ‚ä¢Sort A √ó Œì ‚ä¢Sort B √ó (Œì ‚ä¢Sort A ‚â° B)

  -- Term equality with well-formed terms
  _‚ä¢_:‚â°:_‚à∂_ : (Œì : Con (Entry P) n) ‚Üí Term P n ‚Üí Term P n ‚Üí Term P n ‚Üí Set
  Œì ‚ä¢Sort t :‚â°: u ‚à∂ A = (Œì ‚ä¢Sort t ‚à∂ A) √ó (Œì ‚ä¢Sort u ‚à∂ A) √ó (Œì ‚ä¢Sort t ‚â° u ‚à∂ A)

  -- Type reduction closure with well-formed types
  record _‚ä¢_:‚áí*:_ (Œì : Con (Entry P) n) (A B : Term P n) : Set where
    constructor [_,_,_]
    field
      ‚ä¢A : Œì ‚ä¢Sort A
      ‚ä¢B : Œì ‚ä¢Sort B
      D  : Œì ‚ä¢Sort A ‚áí* B

  open _‚ä¢_:‚áí*:_ using () renaming (D to red; ‚ä¢A to ‚ä¢A-red; ‚ä¢B to ‚ä¢B-red) public

  -- Term reduction closure with well-formed terms
  record _‚ä¢_:‚áí*:_‚à∂_ (Œì : Con (Entry P) n) (t u A : Term P n) : Set where
    constructor [_,_,_]
    field
      ‚ä¢t : Œì ‚ä¢Sort t ‚à∂ A
      ‚ä¢u : Œì ‚ä¢Sort u ‚à∂ A
      d  : Œì ‚ä¢Sort t ‚áí* u ‚à∂ A

  open _‚ä¢_:‚áí*:_‚à∂_ using () renaming (d to red‚Çú; ‚ä¢t to ‚ä¢t-red‚Çú; ‚ä¢u to ‚ä¢u-red‚Çú) public

  -- Well-formed substitutions.
  data _‚ä¢À¢_‚à∂_ (Œî : Con Term m) : (œÉ : Subst m n) (Œì : Con (Entry P) n) ‚Üí Set where
    id  : ‚àÄ {œÉ} ‚Üí Œî ‚ä¢À¢ œÉ ‚à∂ Œµ
    _,_ : ‚àÄ {A œÉ}
        ‚Üí Œî ‚ä¢À¢ tail œÉ ‚à∂ Œì
        ‚Üí Œî ‚ä¢  head œÉ ‚à∂ subst (tail œÉ) A
        ‚Üí Œî ‚ä¢À¢ œÉ      ‚à∂ Œì ‚àô A

  -- Conversion of well-formed substitutions.
  data _‚ä¢À¢_‚â°_‚à∂_ (Œî : Con Term m) : (œÉ œÉ‚Ä≤ : Subst m n) (Œì : Con (Entry P) n) ‚Üí Set where
    id  : ‚àÄ {œÉ œÉ‚Ä≤} ‚Üí Œî ‚ä¢À¢ œÉ ‚â° œÉ‚Ä≤ ‚à∂ Œµ
    _,_ : ‚àÄ {A œÉ œÉ‚Ä≤}
        ‚Üí Œî ‚ä¢À¢ tail œÉ ‚â° tail œÉ‚Ä≤ ‚à∂ Œì
        ‚Üí Œî ‚ä¢  head œÉ ‚â° head œÉ‚Ä≤ ‚à∂ subst (tail œÉ) A
        ‚Üí Œî ‚ä¢À¢      œÉ ‚â° œÉ‚Ä≤      ‚à∂ Œì ‚àô A

  -- Note that we cannot use the well-formed substitutions.
  -- For that, we need to prove the fundamental theorem for substitutions.

  ‚ü¶_‚üß‚±º_‚ñπ_ : (W : BindingType) ‚Üí ‚àÄ {F G}
      ‚Üí Œì     ‚ä¢ F
      ‚Üí Œì ‚àô F ‚ä¢ G
      ‚Üí Œì     ‚ä¢ ‚ü¶ W ‚üß F ‚ñπ G
  ‚ü¶ BŒ† ‚üß‚±º ‚ä¢F ‚ñπ ‚ä¢G = Œ†‚±º ‚ä¢F ‚ñπ ‚ä¢G
  ‚ü¶ BŒ£ ‚üß‚±º ‚ä¢F ‚ñπ ‚ä¢G = Œ£‚±º ‚ä¢F ‚ñπ ‚ä¢G

  ‚ü¶_‚üß‚±º·µ§_‚ñπ_ : (W : BindingType) ‚Üí ‚àÄ {F G}
      ‚Üí Œì     ‚ä¢ F ‚à∂ U
      ‚Üí Œì ‚àô F ‚ä¢ G ‚à∂ U
      ‚Üí Œì     ‚ä¢ ‚ü¶ W ‚üß F ‚ñπ G ‚à∂ U
  ‚ü¶ BŒ† ‚üß‚±º·µ§ ‚ä¢F ‚ñπ ‚ä¢G = Œ†‚±º ‚ä¢F ‚ñπ ‚ä¢G
  ‚ü¶ BŒ£ ‚üß‚±º·µ§ ‚ä¢F ‚ñπ ‚ä¢G = Œ£‚±º ‚ä¢F ‚ñπ ‚ä¢G

  -}

-}
-}
